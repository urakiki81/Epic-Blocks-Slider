'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_rollupPluginBabelHelpers-8f9a8751.js');
var createComponent = require('reakit-system/createComponent');
var createHook = require('reakit-system/createHook');
require('reakit-utils/shallowEqual');
var Box = require('../Box/Box.js');
var React = require('react');
var useForkRef = require('reakit-utils/useForkRef');
require('reakit-utils/isButton');
var reakitWarning = require('reakit-warning');
var useLiveRef = require('reakit-utils/useLiveRef');
var isSelfTarget = require('reakit-utils/isSelfTarget');
require('reakit-utils/useIsomorphicEffect');
require('reakit-utils/hasFocusWithin');
require('reakit-utils/isPortalEvent');
var getActiveElement = require('reakit-utils/getActiveElement');
require('reakit-utils/tabbable');
var Tabbable = require('../Tabbable/Tabbable.js');
require('reakit-utils/useSealedState');
var useCreateElement = require('reakit-system/useCreateElement');
var createOnKeyDown = require('reakit-utils/createOnKeyDown');
var getDocument = require('reakit-utils/getDocument');
var fireEvent = require('reakit-utils/fireEvent');
var fireKeyboardEvent = require('reakit-utils/fireKeyboardEvent');
require('reakit-utils/applyState');
require('../Id/IdProvider.js');
require('../Id/IdState.js');
var CompositeState = require('../CompositeState-a8d7b460.js');

var isIE11 = typeof window !== "undefined" && "msCrypto" in window;
function getNextActiveElementOnBlur(event) {
  // IE 11 doesn't support event.relatedTarget on blur.
  // document.activeElement points the the next active element.
  // On modern browsers, document.activeElement points to the current target.
  if (isIE11) {
    var activeElement = getActiveElement.getActiveElement(event.target);
    return activeElement;
  }

  return event.relatedTarget;
}

var validCompositeRoles = ["combobox", "grid", "tablist", "listbox", "menu", "menubar", "toolbar", "radiogroup", "tree", "treegrid"];
var isIE11$1 = typeof window !== "undefined" && "msCrypto" in window;

function canProxyKeyboardEvent(event) {
  if (!isSelfTarget.isSelfTarget(event)) return false;
  if (event.metaKey) return false;
  if (event.key === "Tab") return false;
  return true;
}

function useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {
  var eventHandlerRef = useLiveRef.useLiveRef(htmlEventHandler);
  return React.useCallback(function (event) {
    var _eventHandlerRef$curr;

    if (virtual && canProxyKeyboardEvent(event)) {
      var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;

      if (currentElement) {
        fireKeyboardEvent.fireKeyboardEvent(currentElement, event.type, event); // The event will be triggered on the composite item and then
        // propagated up to this composite element again, so we can pretend
        // that it wasn't called on this component in the first place.

        if (event.currentTarget.contains(currentElement)) {
          event.stopPropagation();
          event.preventDefault();
          return;
        }
      }
    }

    (_eventHandlerRef$curr = eventHandlerRef.current) === null || _eventHandlerRef$curr === void 0 ? void 0 : _eventHandlerRef$curr.call(eventHandlerRef, event);
  }, [virtual, currentItem]);
} // istanbul ignore next


function useActiveElementRef(elementRef) {
  var activeElementRef = React.useRef(null);
  React.useEffect(function () {
    var document = getDocument.getDocument(elementRef.current);

    var onFocus = function onFocus(event) {
      var target = event.target;
      activeElementRef.current = target;
    };

    document.addEventListener("focus", onFocus, true);
    return function () {
      document.removeEventListener("focus", onFocus, true);
    };
  }, []);
  return activeElementRef;
}

function findFirstEnabledItemInTheLastRow(items) {
  return CompositeState.findFirstEnabledItem(CompositeState.flatten(CompositeState.reverse(CompositeState.groupItems(items))));
}

function isItem(items, element) {
  return items === null || items === void 0 ? void 0 : items.some(function (item) {
    return !!element && item.ref.current === element;
  });
}

var useComposite = createHook.createHook({
  name: "Composite",
  compose: [Tabbable.useTabbable],
  useState: CompositeState.useCompositeState,
  useOptions: function useOptions(options) {
    return _rollupPluginBabelHelpers._objectSpread2(_rollupPluginBabelHelpers._objectSpread2({}, options), {}, {
      currentId: CompositeState.getCurrentId(options)
    });
  },
  useProps: function useProps(options, _ref) {
    var htmlRef = _ref.ref,
        htmlOnFocus = _ref.onFocus,
        htmlOnBlur = _ref.onBlur,
        htmlOnKeyDown = _ref.onKeyDown,
        htmlOnKeyUp = _ref.onKeyUp,
        htmlProps = _rollupPluginBabelHelpers._objectWithoutPropertiesLoose(_ref, ["ref", "onFocus", "onBlur", "onKeyDown", "onKeyUp"]);

    var ref = React.useRef(null);
    var currentItem = CompositeState.findEnabledItemById(options.items, options.currentId);
    var previousItem = React.useRef(undefined);
    var onFocusRef = useLiveRef.useLiveRef(htmlOnFocus);
    var onBlurRef = useLiveRef.useLiveRef(htmlOnBlur); // IE 11 doesn't support event.relatedTarget, so we use the active element
    // ref instead.

    var activeElementRef = isIE11$1 ? useActiveElementRef(ref) : undefined;
    React.useEffect(function () {
      var element = ref.current;

      if (!element) {
        process.env.NODE_ENV !== "production" ? reakitWarning.warning(true, "Can't focus composite component because `ref` wasn't passed to component.", "See https://reakit.io/docs/composite") : void 0;
        return;
      }

      if (options.unstable_moves && !currentItem) {
        // If composite.move(null) has been called, the composite container
        // will receive focus.
        element.focus();
      }
    }, [options.unstable_moves, currentItem]);
    var onKeyDown = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDown);
    var onKeyUp = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUp);
    var onFocus = React.useCallback(function (event) {
      var _onFocusRef$current2;

      if (options.unstable_virtual) {
        // IE11 doesn't support event.relatedTarget, so we use the active
        // element ref instead.
        var previousActiveElement = (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || event.relatedTarget;
        var previousActiveElementWasItem = isItem(options.items, previousActiveElement);

        if (isSelfTarget.isSelfTarget(event) && !previousActiveElementWasItem) {
          var _onFocusRef$current, _currentItem$ref$curr;

          // This means that the composite element has been focused while the
          // composite item has not. For example, by clicking on the
          // composite element without touching any item, or by tabbing into
          // the composite element. In this case, we want to trigger focus on
          // the item, just like it would happen with roving tabindex.
          // When it receives focus, the composite item will put focus back
          // on the composite element, in which case hasItemWithFocus will be
          // true.
          (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);
          currentItem === null || currentItem === void 0 ? void 0 : (_currentItem$ref$curr = currentItem.ref.current) === null || _currentItem$ref$curr === void 0 ? void 0 : _currentItem$ref$curr.focus();
          return;
        }

        if (previousActiveElementWasItem) {
          // Composite has been focused as a result of an item receiving
          // focus. The composite item will move focus back to the composite
          // container. In this case, we don't want to propagate this
          // additional event nor call the onFocus handler passed to
          // <Composite onFocus={...} /> (htmlOnFocus). Unless users add DOM
          // event handlers to the composite element directly, this will be
          // like this event has never existed.
          event.stopPropagation();
          return;
        }
      } else if (isSelfTarget.isSelfTarget(event)) {
        var _options$setCurrentId;

        // When the roving tabindex composite gets intentionally focused (for
        // example, by clicking directly on it, and not on an item), we make
        // sure to set the current id to null (which means the composite
        // itself is focused).
        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);
      }

      (_onFocusRef$current2 = onFocusRef.current) === null || _onFocusRef$current2 === void 0 ? void 0 : _onFocusRef$current2.call(onFocusRef, event);
    }, [options.unstable_virtual, options.items, currentItem, options.setCurrentId]);
    var onBlur = React.useCallback(function (event) {
      var _onBlurRef$current;

      // When virtual is set to true, we move focus from the composite
      // container (this component) to the composite item that is being
      // selected. Then we move focus back to the composite container. This
      // is so we can provide the same API as the roving tabindex method,
      // which means people can attach onFocus/onBlur handlers on the
      // CompositeItem component regardless of whether it's virtual or not.
      // This sequence of blurring and focusing items and composite may be
      // confusing, so we ignore intermediate focus and blurs by stopping its
      // propagation and not calling the passed onBlur handler (htmlOnBlur).
      if (options.unstable_virtual) {
        var targetIsItem = isItem(options.items, event.target);
        var nextActiveElement = getNextActiveElementOnBlur(event);
        var nextActiveElementIsItem = isItem(options.items, nextActiveElement);

        if (isSelfTarget.isSelfTarget(event) && nextActiveElementIsItem) {
          var _previousItem$current;

          // This is an intermediate blur event: blurring the composite
          // container to focus an item (nextActiveElement). We ignore this
          // event.
          if ((_previousItem$current = previousItem.current) === null || _previousItem$current === void 0 ? void 0 : _previousItem$current.ref.current) {
            // If there's a previous active item we fire a blur event on it
            // so it will work just like if it had DOM focus before (like when
            // using roving tabindex).
            fireEvent.fireEvent(previousItem.current.ref.current, "blur", event);
          }

          previousItem.current = currentItem;
          event.stopPropagation();
          return;
        }

        if (!targetIsItem) {
          // If target is another thing (probably something outside of the
          // composite container), we don't ignore the event, but we should
          // reset the previousItem reference.
          if (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) {
            fireEvent.fireEvent(currentItem.ref.current, "blur", event);
          }

          previousItem.current = undefined;
        } else {
          previousItem.current = currentItem;
        }
      }

      (_onBlurRef$current = onBlurRef.current) === null || _onBlurRef$current === void 0 ? void 0 : _onBlurRef$current.call(onBlurRef, event);
    }, [options.unstable_virtual, options.items, currentItem]);
    var onMove = React.useMemo(function () {
      return createOnKeyDown.createOnKeyDown({
        onKeyDown: onKeyDown,
        stopPropagation: true,
        shouldKeyDown: function shouldKeyDown(event) {
          return isSelfTarget.isSelfTarget(event) && options.currentId === null;
        },
        keyMap: function keyMap() {
          var _options$groups;

          var isVertical = options.orientation !== "horizontal";
          var isHorizontal = options.orientation !== "vertical";
          var isGrid = !!((_options$groups = options.groups) === null || _options$groups === void 0 ? void 0 : _options$groups.length);

          var up = function up() {
            if (isGrid) {
              var item = findFirstEnabledItemInTheLastRow(options.items);

              if (item === null || item === void 0 ? void 0 : item.id) {
                var _options$move;

                (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item.id);
              }
            } else {
              var _options$last;

              (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);
            }
          };

          var first = options.first && function () {
            return options.first();
          };

          var last = options.last && function () {
            return options.last();
          };

          return {
            ArrowUp: (isGrid || isVertical) && up,
            ArrowRight: (isGrid || isHorizontal) && first,
            ArrowDown: (isGrid || isVertical) && first,
            ArrowLeft: (isGrid || isHorizontal) && last,
            Home: first,
            End: last,
            PageUp: first,
            PageDown: last
          };
        }
      });
    }, [onKeyDown, options.currentId, options.orientation, options.groups, options.items, options.move, options.last, options.first]);
    return _rollupPluginBabelHelpers._objectSpread2({
      ref: useForkRef.useForkRef(ref, htmlRef),
      id: options.baseId,
      onFocus: onFocus,
      onBlur: onBlur,
      onKeyDown: onMove,
      onKeyUp: onKeyUp,
      "aria-activedescendant": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || undefined : undefined
    }, htmlProps);
  },
  useComposeProps: function useComposeProps(options, htmlProps) {
    htmlProps = Box.useBox(options, htmlProps, true);
    var tabbableHTMLProps = Tabbable.useTabbable(options, htmlProps, true);

    if (options.unstable_virtual || options.currentId === null) {
      // Composite will only be tabbable by default if the focus is managed
      // using aria-activedescendant, which requires DOM focus on the container
      // element (the composite)
      return tabbableHTMLProps;
    }

    return _rollupPluginBabelHelpers._objectSpread2(_rollupPluginBabelHelpers._objectSpread2({}, htmlProps), {}, {
      ref: tabbableHTMLProps.ref
    });
  }
});
var Composite = createComponent.createComponent({
  as: "div",
  useHook: useComposite,
  useCreateElement: function useCreateElement$1(type, props, children) {
    process.env.NODE_ENV !== "production" ? reakitWarning.useWarning(!props.role || validCompositeRoles.indexOf(props.role) === -1, "You should provide a valid `role` attribute to composite components.", "See https://reakit.io/docs/composite") : void 0;
    process.env.NODE_ENV !== "production" ? reakitWarning.useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/composite") : void 0;
    return useCreateElement.useCreateElement(type, props, children);
  }
});

exports.Composite = Composite;
exports.useComposite = useComposite;
