{"version":3,"sources":["@wordpress/core-data/src/queried-data/selectors.js"],"names":["createSelector","EquivalentKeyMap","get","has","set","getQueryParts","queriedItemsCacheByState","WeakMap","getQueriedItemsUncached","state","query","stableKey","page","perPage","include","fields","itemIds","Array","isArray","queries","startOffset","endOffset","length","Math","min","items","i","itemId","includes","hasOwnProperty","item","filteredItem","f","field","split","value","itemIsComplete","push","getQueriedItems","queriedItemsCache","queriedItems","undefined"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport EquivalentKeyMap from 'equivalent-key-map';\nimport { get, has, set } from 'lodash';\n\n/**\n * Internal dependencies\n */\nimport getQueryParts from './get-query-parts';\n\n/**\n * Cache of state keys to EquivalentKeyMap where the inner map tracks queries\n * to their resulting items set. WeakMap allows garbage collection on expired\n * state references.\n *\n * @type {WeakMap<Object,EquivalentKeyMap>}\n */\nconst queriedItemsCacheByState = new WeakMap();\n\n/**\n * Returns items for a given query, or null if the items are not known.\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nfunction getQueriedItemsUncached( state, query ) {\n\tconst { stableKey, page, perPage, include, fields } = getQueryParts(\n\t\tquery\n\t);\n\n\tlet itemIds;\n\tif ( Array.isArray( include ) && ! stableKey ) {\n\t\t// If the parsed query yields a set of IDs, but otherwise no filtering,\n\t\t// it's safe to consider targeted item IDs as the include set. This\n\t\t// doesn't guarantee that those objects have been queried, which is\n\t\t// accounted for below in the loop `null` return.\n\t\titemIds = include;\n\t\t// TODO: Avoid storing the empty stable string in reducer, since it\n\t\t// can be computed dynamically here always.\n\t} else if ( state.queries[ stableKey ] ) {\n\t\titemIds = state.queries[ stableKey ];\n\t}\n\n\tif ( ! itemIds ) {\n\t\treturn null;\n\t}\n\n\tconst startOffset = perPage === -1 ? 0 : ( page - 1 ) * perPage;\n\tconst endOffset =\n\t\tperPage === -1\n\t\t\t? itemIds.length\n\t\t\t: Math.min( startOffset + perPage, itemIds.length );\n\n\tconst items = [];\n\tfor ( let i = startOffset; i < endOffset; i++ ) {\n\t\tconst itemId = itemIds[ i ];\n\t\tif ( Array.isArray( include ) && ! include.includes( itemId ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( ! state.items.hasOwnProperty( itemId ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst item = state.items[ itemId ];\n\n\t\tlet filteredItem;\n\t\tif ( Array.isArray( fields ) ) {\n\t\t\tfilteredItem = {};\n\n\t\t\tfor ( let f = 0; f < fields.length; f++ ) {\n\t\t\t\t// Abort the entire request if a field is missing from the item.\n\t\t\t\t// This accounts for the fact that queried items are stored by\n\t\t\t\t// stable key without an associated fields query. Other requests\n\t\t\t\t// may have included fewer fields properties.\n\t\t\t\tconst field = fields[ f ].split( '.' );\n\t\t\t\tif ( ! has( item, field ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst value = get( item, field );\n\t\t\t\tset( filteredItem, field, value );\n\t\t\t}\n\t\t} else {\n\t\t\t// If expecting a complete item, validate that completeness, or\n\t\t\t// otherwise abort.\n\t\t\tif ( ! state.itemIsComplete[ itemId ] ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tfilteredItem = item;\n\t\t}\n\n\t\titems.push( filteredItem );\n\t}\n\n\treturn items;\n}\n\n/**\n * Returns items for a given query, or null if the items are not known. Caches\n * result both per state (by reference) and per query (by deep equality).\n * The caching approach is intended to be durable to query objects which are\n * deeply but not referentially equal, since otherwise:\n *\n * `getQueriedItems( state, {} ) !== getQueriedItems( state, {} )`\n *\n * @param {Object}  state State object.\n * @param {?Object} query Optional query.\n *\n * @return {?Array} Query items.\n */\nexport const getQueriedItems = createSelector( ( state, query = {} ) => {\n\tlet queriedItemsCache = queriedItemsCacheByState.get( state );\n\tif ( queriedItemsCache ) {\n\t\tconst queriedItems = queriedItemsCache.get( query );\n\t\tif ( queriedItems !== undefined ) {\n\t\t\treturn queriedItems;\n\t\t}\n\t} else {\n\t\tqueriedItemsCache = new EquivalentKeyMap();\n\t\tqueriedItemsCacheByState.set( state, queriedItemsCache );\n\t}\n\n\tconst items = getQueriedItemsUncached( state, query );\n\tqueriedItemsCache.set( query, items );\n\treturn items;\n} );\n"]}