"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMergedItemIds = getMergedItemIds;
exports.itemIsComplete = itemIsComplete;
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _data = require("@wordpress/data");

var _utils = require("../utils");

var _entities = require("../entities");

var _getQueryParts = _interopRequireDefault(require("./get-query-parts"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Returns a merged array of item IDs, given details of the received paginated
 * items. The array is sparse-like with `undefined` entries where holes exist.
 *
 * @param {?Array<number>} itemIds     Original item IDs (default empty array).
 * @param {number[]}       nextItemIds Item IDs to merge.
 * @param {number}         page        Page of items merged.
 * @param {number}         perPage     Number of items per page.
 *
 * @return {number[]} Merged array of item IDs.
 */
function getMergedItemIds(itemIds, nextItemIds, page, perPage) {
  var receivedAllIds = page === 1 && perPage === -1;

  if (receivedAllIds) {
    return nextItemIds;
  }

  var nextItemIdsStartIndex = (page - 1) * perPage; // If later page has already been received, default to the larger known
  // size of the existing array, else calculate as extending the existing.

  var size = Math.max(itemIds.length, nextItemIdsStartIndex + nextItemIds.length); // Preallocate array since size is known.

  var mergedItemIds = new Array(size);

  for (var i = 0; i < size; i++) {
    // Preserve existing item ID except for subset of range of next items.
    var isInNextItemsRange = i >= nextItemIdsStartIndex && i < nextItemIdsStartIndex + nextItemIds.length;
    mergedItemIds[i] = isInNextItemsRange ? nextItemIds[i - nextItemIdsStartIndex] : itemIds[i];
  }

  return mergedItemIds;
}
/**
 * Reducer tracking items state, keyed by ID. Items are assumed to be normal,
 * where identifiers are common across all queries.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Next state.
 */


function items() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'RECEIVE_ITEMS':
      var key = action.key || _entities.DEFAULT_ENTITY_KEY;
      return _objectSpread({}, state, {}, action.items.reduce(function (accumulator, value) {
        var itemId = value[key];
        accumulator[itemId] = (0, _utils.conservativeMapItem)(state[itemId], value);
        return accumulator;
      }, {}));

    case 'REMOVE_ITEMS':
      var newState = (0, _lodash.omit)(state, action.itemIds);
      return newState;
  }

  return state;
}
/**
 * Reducer tracking item completeness, keyed by ID. A complete item is one for
 * which all fields are known. This is used in supporting `_fields` queries,
 * where not all properties associated with an entity are necessarily returned.
 * In such cases, completeness is used as an indication of whether it would be
 * safe to use queried data for a non-`_fields`-limited request.
 *
 * @param {Object<string,boolean>} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object<string,boolean>} Next state.
 */


function itemIsComplete() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var type = action.type,
      query = action.query,
      _action$key = action.key,
      key = _action$key === void 0 ? _entities.DEFAULT_ENTITY_KEY : _action$key;

  if (type !== 'RECEIVE_ITEMS') {
    return state;
  } // An item is considered complete if it is received without an associated
  // fields query. Ideally, this would be implemented in such a way where the
  // complete aggregate of all fields would satisfy completeness. Since the
  // fields are not consistent across all entity types, this would require
  // introspection on the REST schema for each entity to know which fields
  // compose a complete item for that entity.


  var isCompleteQuery = !query || !Array.isArray((0, _getQueryParts.default)(query).fields);
  return _objectSpread({}, state, {}, action.items.reduce(function (result, item) {
    var itemId = item[key]; // Defer to completeness if already assigned. Technically the
    // data may be outdated if receiving items for a field subset.

    result[itemId] = state[itemId] || isCompleteQuery;
    return result;
  }, {}));
}
/**
 * Reducer tracking queries state, keyed by stable query key. Each reducer
 * query object includes `itemIds` and `requestingPageByPerPage`.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Next state.
 */


var receiveQueries = (0, _lodash.flowRight)([// Limit to matching action type so we don't attempt to replace action on
// an unhandled action.
(0, _utils.ifMatchingAction)(function (action) {
  return 'query' in action;
}), // Inject query parts into action for use both in `onSubKey` and reducer.
(0, _utils.replaceAction)(function (action) {
  // `ifMatchingAction` still passes on initialization, where state is
  // undefined and a query is not assigned. Avoid attempting to parse
  // parts. `onSubKey` will omit by lack of `stableKey`.
  if (action.query) {
    return _objectSpread({}, action, {}, (0, _getQueryParts.default)(action.query));
  }

  return action;
}), // Queries shape is shared, but keyed by query `stableKey` part. Original
// reducer tracks only a single query object.
(0, _utils.onSubKey)('stableKey')])(function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var type = action.type,
      page = action.page,
      perPage = action.perPage,
      _action$key2 = action.key,
      key = _action$key2 === void 0 ? _entities.DEFAULT_ENTITY_KEY : _action$key2;

  if (type !== 'RECEIVE_ITEMS') {
    return state;
  }

  return getMergedItemIds(state || [], (0, _lodash.map)(action.items, key), page, perPage);
});
/**
 * Reducer tracking queries state.
 *
 * @param {Object} state  Current state.
 * @param {Object} action Dispatched action.
 *
 * @return {Object} Next state.
 */

var queries = function queries() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case 'RECEIVE_ITEMS':
      return receiveQueries(state, action);

    case 'REMOVE_ITEMS':
      var newState = _objectSpread({}, state);

      var removedItems = action.itemIds.reduce(function (result, itemId) {
        result[itemId] = true;
        return result;
      }, {});
      (0, _lodash.forEach)(newState, function (queryItems, key) {
        newState[key] = (0, _lodash.filter)(queryItems, function (queryId) {
          return !removedItems[queryId];
        });
      });
      return newState;

    default:
      return state;
  }
};

var _default = (0, _data.combineReducers)({
  items: items,
  itemIsComplete: itemIsComplete,
  queries: queries
});

exports.default = _default;
//# sourceMappingURL=reducer.js.map