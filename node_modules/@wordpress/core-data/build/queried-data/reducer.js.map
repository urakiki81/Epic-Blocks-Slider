{"version":3,"sources":["@wordpress/core-data/src/queried-data/reducer.js"],"names":["getMergedItemIds","itemIds","nextItemIds","page","perPage","receivedAllIds","nextItemIdsStartIndex","size","Math","max","length","mergedItemIds","Array","i","isInNextItemsRange","items","state","action","type","key","DEFAULT_ENTITY_KEY","reduce","accumulator","value","itemId","newState","itemIsComplete","query","isCompleteQuery","isArray","fields","result","item","receiveQueries","queries","removedItems","queryItems","queryId"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { map, flowRight, omit, forEach, filter } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport {\n\tconservativeMapItem,\n\tifMatchingAction,\n\treplaceAction,\n\tonSubKey,\n} from '../utils';\nimport { DEFAULT_ENTITY_KEY } from '../entities';\nimport getQueryParts from './get-query-parts';\n\n/**\n * Returns a merged array of item IDs, given details of the received paginated\n * items. The array is sparse-like with `undefined` entries where holes exist.\n *\n * @param {?Array<number>} itemIds     Original item IDs (default empty array).\n * @param {number[]}       nextItemIds Item IDs to merge.\n * @param {number}         page        Page of items merged.\n * @param {number}         perPage     Number of items per page.\n *\n * @return {number[]} Merged array of item IDs.\n */\nexport function getMergedItemIds( itemIds, nextItemIds, page, perPage ) {\n\tconst receivedAllIds = page === 1 && perPage === -1;\n\tif ( receivedAllIds ) {\n\t\treturn nextItemIds;\n\t}\n\tconst nextItemIdsStartIndex = ( page - 1 ) * perPage;\n\n\t// If later page has already been received, default to the larger known\n\t// size of the existing array, else calculate as extending the existing.\n\tconst size = Math.max(\n\t\titemIds.length,\n\t\tnextItemIdsStartIndex + nextItemIds.length\n\t);\n\n\t// Preallocate array since size is known.\n\tconst mergedItemIds = new Array( size );\n\n\tfor ( let i = 0; i < size; i++ ) {\n\t\t// Preserve existing item ID except for subset of range of next items.\n\t\tconst isInNextItemsRange =\n\t\t\ti >= nextItemIdsStartIndex &&\n\t\t\ti < nextItemIdsStartIndex + nextItemIds.length;\n\n\t\tmergedItemIds[ i ] = isInNextItemsRange\n\t\t\t? nextItemIds[ i - nextItemIdsStartIndex ]\n\t\t\t: itemIds[ i ];\n\t}\n\n\treturn mergedItemIds;\n}\n\n/**\n * Reducer tracking items state, keyed by ID. Items are assumed to be normal,\n * where identifiers are common across all queries.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nfunction items( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS':\n\t\t\tconst key = action.key || DEFAULT_ENTITY_KEY;\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t...action.items.reduce( ( accumulator, value ) => {\n\t\t\t\t\tconst itemId = value[ key ];\n\t\t\t\t\taccumulator[ itemId ] = conservativeMapItem(\n\t\t\t\t\t\tstate[ itemId ],\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\t\t\t\t\treturn accumulator;\n\t\t\t\t}, {} ),\n\t\t\t};\n\t\tcase 'REMOVE_ITEMS':\n\t\t\tconst newState = omit( state, action.itemIds );\n\t\t\treturn newState;\n\t}\n\treturn state;\n}\n\n/**\n * Reducer tracking item completeness, keyed by ID. A complete item is one for\n * which all fields are known. This is used in supporting `_fields` queries,\n * where not all properties associated with an entity are necessarily returned.\n * In such cases, completeness is used as an indication of whether it would be\n * safe to use queried data for a non-`_fields`-limited request.\n *\n * @param {Object<string,boolean>} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object<string,boolean>} Next state.\n */\nexport function itemIsComplete( state = {}, action ) {\n\tconst { type, query, key = DEFAULT_ENTITY_KEY } = action;\n\tif ( type !== 'RECEIVE_ITEMS' ) {\n\t\treturn state;\n\t}\n\n\t// An item is considered complete if it is received without an associated\n\t// fields query. Ideally, this would be implemented in such a way where the\n\t// complete aggregate of all fields would satisfy completeness. Since the\n\t// fields are not consistent across all entity types, this would require\n\t// introspection on the REST schema for each entity to know which fields\n\t// compose a complete item for that entity.\n\tconst isCompleteQuery =\n\t\t! query || ! Array.isArray( getQueryParts( query ).fields );\n\n\treturn {\n\t\t...state,\n\t\t...action.items.reduce( ( result, item ) => {\n\t\t\tconst itemId = item[ key ];\n\n\t\t\t// Defer to completeness if already assigned. Technically the\n\t\t\t// data may be outdated if receiving items for a field subset.\n\t\t\tresult[ itemId ] = state[ itemId ] || isCompleteQuery;\n\n\t\t\treturn result;\n\t\t}, {} ),\n\t};\n}\n\n/**\n * Reducer tracking queries state, keyed by stable query key. Each reducer\n * query object includes `itemIds` and `requestingPageByPerPage`.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst receiveQueries = flowRight( [\n\t// Limit to matching action type so we don't attempt to replace action on\n\t// an unhandled action.\n\tifMatchingAction( ( action ) => 'query' in action ),\n\n\t// Inject query parts into action for use both in `onSubKey` and reducer.\n\treplaceAction( ( action ) => {\n\t\t// `ifMatchingAction` still passes on initialization, where state is\n\t\t// undefined and a query is not assigned. Avoid attempting to parse\n\t\t// parts. `onSubKey` will omit by lack of `stableKey`.\n\t\tif ( action.query ) {\n\t\t\treturn {\n\t\t\t\t...action,\n\t\t\t\t...getQueryParts( action.query ),\n\t\t\t};\n\t\t}\n\n\t\treturn action;\n\t} ),\n\n\t// Queries shape is shared, but keyed by query `stableKey` part. Original\n\t// reducer tracks only a single query object.\n\tonSubKey( 'stableKey' ),\n] )( ( state = null, action ) => {\n\tconst { type, page, perPage, key = DEFAULT_ENTITY_KEY } = action;\n\n\tif ( type !== 'RECEIVE_ITEMS' ) {\n\t\treturn state;\n\t}\n\n\treturn getMergedItemIds(\n\t\tstate || [],\n\t\tmap( action.items, key ),\n\t\tpage,\n\t\tperPage\n\t);\n} );\n\n/**\n * Reducer tracking queries state.\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Next state.\n */\nconst queries = ( state = {}, action ) => {\n\tswitch ( action.type ) {\n\t\tcase 'RECEIVE_ITEMS':\n\t\t\treturn receiveQueries( state, action );\n\t\tcase 'REMOVE_ITEMS':\n\t\t\tconst newState = { ...state };\n\t\t\tconst removedItems = action.itemIds.reduce( ( result, itemId ) => {\n\t\t\t\tresult[ itemId ] = true;\n\t\t\t\treturn result;\n\t\t\t}, {} );\n\t\t\tforEach( newState, ( queryItems, key ) => {\n\t\t\t\tnewState[ key ] = filter( queryItems, ( queryId ) => {\n\t\t\t\t\treturn ! removedItems[ queryId ];\n\t\t\t\t} );\n\t\t\t} );\n\t\t\treturn newState;\n\t\tdefault:\n\t\t\treturn state;\n\t}\n};\n\nexport default combineReducers( {\n\titems,\n\titemIsComplete,\n\tqueries,\n} );\n"]}