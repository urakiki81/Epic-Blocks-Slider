"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQueriedItems = void 0;

var _rememo = _interopRequireDefault(require("rememo"));

var _equivalentKeyMap = _interopRequireDefault(require("equivalent-key-map"));

var _lodash = require("lodash");

var _getQueryParts2 = _interopRequireDefault(require("./get-query-parts"));

/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Cache of state keys to EquivalentKeyMap where the inner map tracks queries
 * to their resulting items set. WeakMap allows garbage collection on expired
 * state references.
 *
 * @type {WeakMap<Object,EquivalentKeyMap>}
 */
var queriedItemsCacheByState = new WeakMap();
/**
 * Returns items for a given query, or null if the items are not known.
 *
 * @param {Object}  state State object.
 * @param {?Object} query Optional query.
 *
 * @return {?Array} Query items.
 */

function getQueriedItemsUncached(state, query) {
  var _getQueryParts = (0, _getQueryParts2.default)(query),
      stableKey = _getQueryParts.stableKey,
      page = _getQueryParts.page,
      perPage = _getQueryParts.perPage,
      include = _getQueryParts.include,
      fields = _getQueryParts.fields;

  var itemIds;

  if (Array.isArray(include) && !stableKey) {
    // If the parsed query yields a set of IDs, but otherwise no filtering,
    // it's safe to consider targeted item IDs as the include set. This
    // doesn't guarantee that those objects have been queried, which is
    // accounted for below in the loop `null` return.
    itemIds = include; // TODO: Avoid storing the empty stable string in reducer, since it
    // can be computed dynamically here always.
  } else if (state.queries[stableKey]) {
    itemIds = state.queries[stableKey];
  }

  if (!itemIds) {
    return null;
  }

  var startOffset = perPage === -1 ? 0 : (page - 1) * perPage;
  var endOffset = perPage === -1 ? itemIds.length : Math.min(startOffset + perPage, itemIds.length);
  var items = [];

  for (var i = startOffset; i < endOffset; i++) {
    var itemId = itemIds[i];

    if (Array.isArray(include) && !include.includes(itemId)) {
      continue;
    }

    if (!state.items.hasOwnProperty(itemId)) {
      return null;
    }

    var item = state.items[itemId];
    var filteredItem = void 0;

    if (Array.isArray(fields)) {
      filteredItem = {};

      for (var f = 0; f < fields.length; f++) {
        // Abort the entire request if a field is missing from the item.
        // This accounts for the fact that queried items are stored by
        // stable key without an associated fields query. Other requests
        // may have included fewer fields properties.
        var field = fields[f].split('.');

        if (!(0, _lodash.has)(item, field)) {
          return null;
        }

        var value = (0, _lodash.get)(item, field);
        (0, _lodash.set)(filteredItem, field, value);
      }
    } else {
      // If expecting a complete item, validate that completeness, or
      // otherwise abort.
      if (!state.itemIsComplete[itemId]) {
        return null;
      }

      filteredItem = item;
    }

    items.push(filteredItem);
  }

  return items;
}
/**
 * Returns items for a given query, or null if the items are not known. Caches
 * result both per state (by reference) and per query (by deep equality).
 * The caching approach is intended to be durable to query objects which are
 * deeply but not referentially equal, since otherwise:
 *
 * `getQueriedItems( state, {} ) !== getQueriedItems( state, {} )`
 *
 * @param {Object}  state State object.
 * @param {?Object} query Optional query.
 *
 * @return {?Array} Query items.
 */


var getQueriedItems = (0, _rememo.default)(function (state) {
  var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var queriedItemsCache = queriedItemsCacheByState.get(state);

  if (queriedItemsCache) {
    var queriedItems = queriedItemsCache.get(query);

    if (queriedItems !== undefined) {
      return queriedItems;
    }
  } else {
    queriedItemsCache = new _equivalentKeyMap.default();
    queriedItemsCacheByState.set(state, queriedItemsCache);
  }

  var items = getQueriedItemsUncached(state, query);
  queriedItemsCache.set(query, items);
  return items;
});
exports.getQueriedItems = getQueriedItems;
//# sourceMappingURL=selectors.js.map