"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PostTextEditor;

var _element = require("@wordpress/element");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _reactAutosizeTextarea = _interopRequireDefault(require("react-autosize-textarea"));

var _i18n = require("@wordpress/i18n");

var _blocks = require("@wordpress/blocks");

var _data = require("@wordpress/data");

var _compose = require("@wordpress/compose");

var _components = require("@wordpress/components");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */
function PostTextEditor() {
  var postContent = (0, _data.useSelect)(function (select) {
    return select('core/editor').getEditedPostContent();
  }, []);

  var _useDispatch = (0, _data.useDispatch)('core/editor'),
      editPost = _useDispatch.editPost,
      resetEditorBlocks = _useDispatch.resetEditorBlocks;

  var _useState = (0, _element.useState)(postContent),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var _useState3 = (0, _element.useState)(false),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      isDirty = _useState4[0],
      setIsDirty = _useState4[1];

  var instanceId = (0, _compose.useInstanceId)(PostTextEditor);

  if (!isDirty && value !== postContent) {
    setValue(postContent);
  }
  /**
   * Handles a textarea change event to notify the onChange prop callback and
   * reflect the new value in the component's own state. This marks the start
   * of the user's edits, if not already changed, preventing future props
   * changes to value from replacing the rendered value. This is expected to
   * be followed by a reset to dirty state via `stopEditing`.
   *
   * @see stopEditing
   *
   * @param {Event} event Change event.
   */


  var onChange = function onChange(event) {
    var newValue = event.target.value;
    editPost({
      content: newValue
    });
    setValue(newValue);
    setIsDirty(true);
  };
  /**
   * Function called when the user has completed their edits, responsible for
   * ensuring that changes, if made, are surfaced to the onPersist prop
   * callback and resetting dirty state.
   */


  var stopEditing = function stopEditing() {
    if (isDirty) {
      var blocks = (0, _blocks.parse)(value);
      resetEditorBlocks(blocks);
      setIsDirty(false);
    }
  };

  return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_components.VisuallyHidden, {
    as: "label",
    htmlFor: "post-content-".concat(instanceId)
  }, (0, _i18n.__)('Type text or HTML')), (0, _element.createElement)(_reactAutosizeTextarea.default, {
    autoComplete: "off",
    dir: "auto",
    value: value,
    onChange: onChange,
    onBlur: stopEditing,
    className: "editor-post-text-editor",
    id: "post-content-".concat(instanceId),
    placeholder: (0, _i18n.__)('Start writing with text or HTML')
  }));
}
//# sourceMappingURL=index.js.map