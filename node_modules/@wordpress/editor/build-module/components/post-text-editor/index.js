import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement, Fragment } from "@wordpress/element";

/**
 * External dependencies
 */
import Textarea from 'react-autosize-textarea';
/**
 * WordPress dependencies
 */

import { __ } from '@wordpress/i18n';
import { useState } from '@wordpress/element';
import { parse } from '@wordpress/blocks';
import { useDispatch, useSelect } from '@wordpress/data';
import { useInstanceId } from '@wordpress/compose';
import { VisuallyHidden } from '@wordpress/components';
export default function PostTextEditor() {
  var postContent = useSelect(function (select) {
    return select('core/editor').getEditedPostContent();
  }, []);

  var _useDispatch = useDispatch('core/editor'),
      editPost = _useDispatch.editPost,
      resetEditorBlocks = _useDispatch.resetEditorBlocks;

  var _useState = useState(postContent),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isDirty = _useState4[0],
      setIsDirty = _useState4[1];

  var instanceId = useInstanceId(PostTextEditor);

  if (!isDirty && value !== postContent) {
    setValue(postContent);
  }
  /**
   * Handles a textarea change event to notify the onChange prop callback and
   * reflect the new value in the component's own state. This marks the start
   * of the user's edits, if not already changed, preventing future props
   * changes to value from replacing the rendered value. This is expected to
   * be followed by a reset to dirty state via `stopEditing`.
   *
   * @see stopEditing
   *
   * @param {Event} event Change event.
   */


  var onChange = function onChange(event) {
    var newValue = event.target.value;
    editPost({
      content: newValue
    });
    setValue(newValue);
    setIsDirty(true);
  };
  /**
   * Function called when the user has completed their edits, responsible for
   * ensuring that changes, if made, are surfaced to the onPersist prop
   * callback and resetting dirty state.
   */


  var stopEditing = function stopEditing() {
    if (isDirty) {
      var blocks = parse(value);
      resetEditorBlocks(blocks);
      setIsDirty(false);
    }
  };

  return createElement(Fragment, null, createElement(VisuallyHidden, {
    as: "label",
    htmlFor: "post-content-".concat(instanceId)
  }, __('Type text or HTML')), createElement(Textarea, {
    autoComplete: "off",
    dir: "auto",
    value: value,
    onChange: onChange,
    onBlur: stopEditing,
    className: "editor-post-text-editor",
    id: "post-content-".concat(instanceId),
    placeholder: __('Start writing with text or HTML')
  }));
}
//# sourceMappingURL=index.js.map