import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { Animate, Button } from '@wordpress/components';
import { usePrevious, useViewportMatch } from '@wordpress/compose';
import { useDispatch, useSelect } from '@wordpress/data';
import { useEffect, useState } from '@wordpress/element';
import { __ } from '@wordpress/i18n';
import { Icon, check, cloud, cloudUpload } from '@wordpress/icons';
import { displayShortcut } from '@wordpress/keycodes';
/**
 * Internal dependencies
 */

import PostSwitchToDraftButton from '../post-switch-to-draft-button';
/**
 * Component showing whether the post is saved or not and providing save
 * buttons.
 *
 * @param {Object} props               Component props.
 * @param {?boolean} props.forceIsDirty  Whether to force the post to be marked
 * as dirty.
 * @param {?boolean} props.forceIsSaving Whether to force the post to be marked
 * as being saved.
 * @param {?boolean} props.showIconLabels Whether interface buttons show labels instead of icons
 * @return {import('@wordpress/element').WPComponent} The component.
 */

export default function PostSavedState(_ref) {
  var forceIsDirty = _ref.forceIsDirty,
      forceIsSaving = _ref.forceIsSaving,
      _ref$showIconLabels = _ref.showIconLabels,
      showIconLabels = _ref$showIconLabels === void 0 ? false : _ref$showIconLabels;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      forceSavedMessage = _useState2[0],
      setForceSavedMessage = _useState2[1];

  var isLargeViewport = useViewportMatch('small');

  var _useSelect = useSelect(function (select) {
    var _getCurrentPost$_link, _getCurrentPost, _getCurrentPost$_link2;

    var _select = select('core/editor'),
        isEditedPostNew = _select.isEditedPostNew,
        isCurrentPostPublished = _select.isCurrentPostPublished,
        isCurrentPostScheduled = _select.isCurrentPostScheduled,
        isEditedPostDirty = _select.isEditedPostDirty,
        isSavingPost = _select.isSavingPost,
        isEditedPostSaveable = _select.isEditedPostSaveable,
        getCurrentPost = _select.getCurrentPost,
        isAutosavingPost = _select.isAutosavingPost,
        getEditedPostAttribute = _select.getEditedPostAttribute;

    return {
      isAutosaving: isAutosavingPost(),
      isDirty: forceIsDirty || isEditedPostDirty(),
      isNew: isEditedPostNew(),
      isPending: 'pending' === getEditedPostAttribute('status'),
      isPublished: isCurrentPostPublished(),
      isSaving: forceIsSaving || isSavingPost(),
      isSaveable: isEditedPostSaveable(),
      isScheduled: isCurrentPostScheduled(),
      hasPublishAction: (_getCurrentPost$_link = (_getCurrentPost = getCurrentPost()) === null || _getCurrentPost === void 0 ? void 0 : (_getCurrentPost$_link2 = _getCurrentPost['_links']) === null || _getCurrentPost$_link2 === void 0 ? void 0 : _getCurrentPost$_link2['wp:action-publish']) !== null && _getCurrentPost$_link !== void 0 ? _getCurrentPost$_link : false
    };
  }, [forceIsDirty, forceIsSaving]),
      isAutosaving = _useSelect.isAutosaving,
      isDirty = _useSelect.isDirty,
      isNew = _useSelect.isNew,
      isPending = _useSelect.isPending,
      isPublished = _useSelect.isPublished,
      isSaveable = _useSelect.isSaveable,
      isSaving = _useSelect.isSaving,
      isScheduled = _useSelect.isScheduled,
      hasPublishAction = _useSelect.hasPublishAction;

  var _useDispatch = useDispatch('core/editor'),
      savePost = _useDispatch.savePost;

  var wasSaving = usePrevious(isSaving);
  useEffect(function () {
    var timeoutId;

    if (wasSaving && !isSaving) {
      setForceSavedMessage(true);
      timeoutId = setTimeout(function () {
        setForceSavedMessage(false);
      }, 1000);
    }

    return function () {
      return clearTimeout(timeoutId);
    };
  }, [isSaving]);

  if (isSaving) {
    // TODO: Classes generation should be common across all return
    // paths of this function, including proper naming convention for
    // the "Save Draft" button.
    var classes = classnames('editor-post-saved-state', 'is-saving', {
      'is-autosaving': isAutosaving
    });
    return createElement(Animate, {
      type: "loading"
    }, function (_ref2) {
      var animateClassName = _ref2.className;
      return createElement("span", {
        className: classnames(classes, animateClassName)
      }, createElement(Icon, {
        icon: cloud
      }), isAutosaving ? __('Autosaving') : __('Saving'));
    });
  }

  if (isPublished || isScheduled) {
    return createElement(PostSwitchToDraftButton, null);
  }

  if (!isSaveable) {
    return null;
  }

  if (forceSavedMessage || !isNew && !isDirty) {
    return createElement("span", {
      className: "editor-post-saved-state is-saved"
    }, createElement(Icon, {
      icon: check
    }), __('Saved'));
  } // Once the post has been submitted for review this button
  // is not needed for the contributor role.


  if (!hasPublishAction && isPending) {
    return null;
  }
  /* translators: button label text should, if possible, be under 16 characters. */


  var label = isPending ? __('Save as pending') : __('Save draft');
  /* translators: button label text should, if possible, be under 16 characters. */

  var shortLabel = __('Save');

  if (!isLargeViewport) {
    return createElement(Button, {
      className: "editor-post-save-draft",
      label: label,
      onClick: function onClick() {
        return savePost();
      },
      shortcut: displayShortcut.primary('s'),
      icon: cloudUpload
    }, showIconLabels && shortLabel);
  }

  return createElement(Button, {
    className: "editor-post-save-draft",
    onClick: function onClick() {
      return savePost();
    },
    shortcut: displayShortcut.primary('s'),
    isTertiary: true
  }, label);
}
//# sourceMappingURL=index.js.map