{"version":3,"file":"react-easy-crop.min.js","sources":["../../src/helpers.ts","../../src/index.tsx"],"sourcesContent":["import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = translateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = translateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n  return Math.min(maxPosition, Math.max(position, -maxPosition))\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition && rotation === 0 ? limitArea : noOp\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaSize.width) * 100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaSize.height) * 100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalWidth,\n      (croppedAreaPercentages.width * mediaSize.naturalWidth) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalHeight,\n      (croppedAreaPercentages.height * mediaSize.naturalHeight) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to iamge height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaSize.naturalWidth - sizePixels.width,\n        (croppedAreaPercentages.x * mediaSize.naturalWidth) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaSize.naturalHeight - sizePixels.height,\n        (croppedAreaPercentages.y * mediaSize.naturalHeight) / 100\n      )\n    ),\n  }\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): number {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  if (cropSize) {\n    const isHeightMaxSize = cropSize.height > cropSize.width\n    return isHeightMaxSize\n      ? cropSize.height / mediaZoom / croppedAreaPixels.height\n      : cropSize.width / mediaZoom / croppedAreaPixels.width\n  }\n\n  const aspect = croppedAreaPixels.width / croppedAreaPixels.height\n  const isHeightMaxSize = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n  return isHeightMaxSize\n    ? mediaSize.naturalHeight / croppedAreaPixels.height\n    : mediaSize.naturalWidth / croppedAreaPixels.width\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): { crop: Point; zoom: number } {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  const zoom = getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize)\n\n  const cropZoom = mediaZoom * zoom\n\n  const crop = {\n    x: ((mediaSize.naturalWidth - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaSize.naturalHeight - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\n/**\n *\n * Returns an x,y point once rotated around xMid,yMid\n */\nexport function rotateAroundMidPoint(\n  x: number,\n  y: number,\n  xMid: number,\n  yMid: number,\n  degrees: number\n): [number, number] {\n  const cos = Math.cos\n  const sin = Math.sin\n  const radian = (degrees * Math.PI) / 180 // Convert to radians\n  // Subtract midpoints, so that midpoint is translated to origin\n  // and add it in the end again\n  const xr = (x - xMid) * cos(radian) - (y - yMid) * sin(radian) + xMid\n  const yr = (x - xMid) * sin(radian) + (y - yMid) * cos(radian) + yMid\n\n  return [xr, yr]\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function translateSize(width: number, height: number, rotation: number): Size {\n  const centerX = width / 2\n  const centerY = height / 2\n\n  const outerBounds = [\n    rotateAroundMidPoint(0, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, height, centerX, centerY, rotation),\n    rotateAroundMidPoint(0, height, centerX, centerY, rotation),\n  ]\n\n  const minX = Math.min(...outerBounds.map(p => p[0]))\n  const maxX = Math.max(...outerBounds.map(p => p[0]))\n  const minY = Math.min(...outerBounds.map(p => p[1]))\n  const maxY = Math.max(...outerBounds.map(p => p[1]))\n\n  return { width: maxX - minX, height: maxY - minY }\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter(value => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import React from 'react'\nimport { Area, MediaSize, Point, Size } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  classNames,\n} from './helpers'\nimport cssStyles from './styles.css'\n\ntype Props = {\n  image?: string\n  video?: string\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  initialCroppedAreaPixels?: Area\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\nclass Cropper extends React.Component<Props, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: HTMLImageElement | null = null\n  videoRef: HTMLVideoElement | null = null\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = document.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      this.styleRef.innerHTML = cssStyles\n      document.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad()\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.remove()\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    document.removeEventListener('mousemove', this.onMouseMove)\n    document.removeEventListener('mouseup', this.onDragStopped)\n    document.removeEventListener('touchmove', this.onTouchMove)\n    document.removeEventListener('touchend', this.onDragStopped)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    this.computeSizes()\n    this.emitCropData()\n    this.setInitialCrop()\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = () => {\n    const { initialCroppedAreaPixels, cropSize } = this.props\n\n    if (!initialCroppedAreaPixels) {\n      return\n    }\n\n    const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n      initialCroppedAreaPixels,\n      this.mediaSize,\n      cropSize\n    )\n    this.props.onCropChange(crop)\n    this.props.onZoomChange && this.props.onZoomChange(zoom)\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef || this.videoRef\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n\n      this.mediaSize = {\n        width: mediaRef.offsetWidth,\n        height: mediaRef.offsetHeight,\n        naturalWidth: this.imageRef?.naturalWidth || this.videoRef?.videoWidth || 0,\n        naturalHeight: this.imageRef?.naturalHeight || this.videoRef?.videoHeight || 0,\n      }\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            mediaRef.offsetWidth,\n            mediaRef.offsetHeight,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.preventDefault()\n    document.addEventListener('mousemove', this.onMouseMove)\n    document.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    e.preventDefault()\n    document.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    document.addEventListener('touchend', this.onDragStopped)\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (this.rafDragTimeout) window.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = window.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = window.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center)\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.props.zoom - (e.deltaY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point)\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = window.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const zoomPoint = this.getPointOnContainer(point)\n    const zoomTarget = this.getPointOnMedia(zoomPoint)\n    const newZoom = Math.min(this.props.maxZoom, Math.max(zoom, this.props.minZoom))\n    const requestedPosition = {\n      x: zoomTarget.x * newZoom - zoomPoint.x,\n      y: zoomTarget.y * newZoom - zoomPoint.y,\n    }\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          requestedPosition,\n          this.mediaSize,\n          this.state.cropSize,\n          newZoom,\n          this.props.rotation\n        )\n      : requestedPosition\n\n    this.props.onCropChange(newPosition)\n    this.props.onZoomChange(newZoom)\n  }\n\n  emitCropData = () => {\n    if (!this.state.cropSize) return\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    const { croppedAreaPercentages, croppedAreaPixels } = computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n    this.props.onCropComplete &&\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n    } = this.props\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={el => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames('reactEasyCrop_Image', mediaClassName)}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={(el: HTMLImageElement) => (this.imageRef = el)}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              loop\n              muted={true}\n              className={classNames('reactEasyCrop_Video', mediaClassName)}\n              {...mediaProps}\n              src={video}\n              ref={(el: HTMLVideoElement) => (this.videoRef = el)}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            />\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"],"names":["getCropSize","mediaWidth","mediaHeight","containerWidth","containerHeight","aspect","rotation","_a","translateSize","width","height","fittingWidth","Math","min","fittingHeight","restrictPosition","position","mediaSize","cropSize","zoom","x","restrictPositionCoord","y","maxPosition","max","getDistanceBetweenPoints","pointA","pointB","sqrt","pow","getRotationBetweenPoints","atan2","PI","computeCroppedArea","crop","limitAreaFn","limitArea","noOp","croppedAreaPercentages","widthInPixels","round","naturalWidth","heightInPixels","naturalHeight","sizePixels","croppedAreaPixels","value","_max","getInitialCropFromCroppedAreaPixels","mediaZoom","getZoomFromCroppedAreaPixels","cropZoom","getCenter","a","b","rotateAroundMidPoint","xMid","yMid","degrees","cos","sin","radian","centerX","centerY","outerBounds","minX","map","p","maxX","minY","classNames","_i","args","filter","length","join","trim","_this","hasWheelJustStarted","e","preventDefault","document","removeEventListener","onMouseMove","onDragStopped","onTouchMove","containerRef","onWheel","wheelTimer","clearTimeout","computeSizes","emitCropData","setInitialCrop","props","onMediaLoaded","initialCroppedAreaPixels","_b","onCropChange","onZoomChange","mediaRef","imageRef","videoRef","containerRect","getBoundingClientRect","offsetWidth","offsetHeight","videoWidth","videoHeight","state","onCropSizeChange","setState","recomputeCropPosition","addEventListener","onDragStart","Cropper","getMousePoint","onDrag","passive","touches","onPinchStart","getTouchPoint","onPinchMove","dragStartPosition","dragStartCrop","onInteractionStart","rafDragTimeout","window","cancelAnimationFrame","requestAnimationFrame","undefined","offsetX","offsetY","requestedPosition","newPosition","cleanEvents","onInteractionEnd","point","newZoom","deltaY","zoomSpeed","setNewZoom","setTimeout","Error","left","top","zoomPoint","getPointOnContainer","zoomTarget","getPointOnMedia","maxZoom","minZoom","getAspect","onCropComplete","__extends","this","zoomWithScroll","preventZoomSafari","disableAutomaticStylesInjection","styleRef","createElement","setAttribute","innerHTML","head","appendChild","complete","onMediaLoad","remove","clearScrollEvent","prevProps","lastPinchDistance","lastPinchRotation","center","rafPinchTimeout","distance","newRotation","onRotationChange","image","video","mediaProps","transform","cropShape","showGrid","_c","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","React","onMouseDown","onTouchStart","ref","el","style","className","alt","src","onLoad","autoPlay","loop","muted","onLoadedMetadata","controls","classes","Number","clientX","clientY","touch","Component"],"mappings":"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"}